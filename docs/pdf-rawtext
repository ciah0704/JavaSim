Object-OrientedDiscrete-EventSimulation in Java

JavaSim Userâ€™s GuidePublic Release 0.3Version 1.0

Department of Computing Science,Computing Laboratory,The University, Newcastle upon Tyne,NE1 7RU, UK.




The JavaSim Userâ€™s ManualsCopyright Notice:Copyright 1995-1999,Computing Laboratory, University of Newcastle upon Tyne, UK.Permission to use, copy, modify and distribute the JavaSim software for evaluation, teachingand/or research purposes only and without fee is hereby granted, providing that thiscopyright and permission notice appear on all copies and supporting documentation, andthat similar conditions are imposed on any individual or organisation to whom the programis distributed.The University of Newcastle upon Tyne makes no representation about the suitability of thissoftware for any purpose. It is provided "as is" without express or implied warranty.




The JavaSim Userâ€™s ManualsTable of Contents1.PREFACE...................................................................................................................................................51.1AVAILABILITY...........................................................................................................................................52.INTRODUCTION.......................................................................................................................................62.1SIMULATION MODELS................................................................................................................................62.2TERMINOLOGY..........................................................................................................................................62.3CATEGORIES OF SIMULATION MODELS.......................................................................................................72.4EVENT SCHEDULING..................................................................................................................................73.BASIC SIMULATION CLASSES.............................................................................................................93.1THE SIMULATION SCHEDULER...................................................................................................................93.1.1Scheduler class interface..............................................................................................................103.2SIMULATION PROCESSES.........................................................................................................................103.2.1SimulationProcess class interface................................................................................................113.2.2Example........................................................................................................................................143.3STARTING, ENDING AND CONTROLLING A SIMULATION............................................................................143.3.1Suspending the main thread.........................................................................................................153.3.2Exiting the application.................................................................................................................153.3.3Controlling the simulation............................................................................................................163.4RESETTING A SIMULATION.......................................................................................................................163.4.1Example........................................................................................................................................174.DISTRIBUTION FUNCTIONS...............................................................................................................184.1RANDOMSTREAM....................................................................................................................................184.2UNIFORMSTREAM...................................................................................................................................194.3EXPONENTIALSTREAM............................................................................................................................194.4ERLANGSTREAM.....................................................................................................................................204.5HYPEREXPONENTIALSTREAM.................................................................................................................204.6NORMALSTREAM....................................................................................................................................204.7DRAW.....................................................................................................................................................214.8EXAMPLE................................................................................................................................................215.ADVANCED SIMULATION CLASSES................................................................................................225.1ASYNCHRONOUS ENTITIES......................................................................................................................235.2TRIGGER QUEUES....................................................................................................................................245.3SEMAPHORES..........................................................................................................................................255.4EXAMPLE................................................................................................................................................266.STATISTICAL CLASSES.......................................................................................................................276.1MEAN.....................................................................................................................................................276.2VARIANCE...............................................................................................................................................286.3TIMEVARIANCE......................................................................................................................................286.4HISTOGRAMS..........................................................................................................................................296.4.1PrecisionHistogram......................................................................................................................296.4.2Histogram.....................................................................................................................................306.4.3SimpleHistogram..........................................................................................................................316.4.4Quantile........................................................................................................................................327.JAVASIM CLASSES................................................................................................................................337.1SCHEDULER............................................................................................................................................337.2SIMULATIONPROCESS.............................................................................................................................347.3SIMULATIONEXCEPTION..........................................................................................................................357.4RESTARTEXCEPTION...............................................................................................................................357.5RANDOMSTREAM....................................................................................................................................357.6UNIFORMSTREAM...................................................................................................................................357.7EXPONENTIALSTREAM............................................................................................................................367.8ERLANGSTREAM.....................................................................................................................................36




The JavaSim Userâ€™s Manuals7.9HYPEREXPONENTIALSTREAM.................................................................................................................367.10NORMALSTREAM...............................................................................................................................367.11DRAW................................................................................................................................................377.12SIMULATIONENTITY...........................................................................................................................377.13TRIGGERQUEUE.................................................................................................................................377.14SEMAPHORE.......................................................................................................................................387.15MEAN.................................................................................................................................................387.16VARIANCE..........................................................................................................................................397.17TIMEVARIANCE..................................................................................................................................397.18PRECISIONHISTOGRAM.......................................................................................................................407.19HISTOGRAM.......................................................................................................................................407.20SIMPLEHISTOGRAM............................................................................................................................417.21QUANTILE..........................................................................................................................................417.22STATISTICSEXCEPTION.......................................................................................................................418.REFERENCES..........................................................................................................................................429.INDEX.......................................................................................................................................................43




The JavaSim Userâ€™s Manuals1. PrefaceJavaSim is a Java implementation of the original C++SIM simulation toolkit, which wasdeveloped as a direct consequence of research conducted within the scope of the Arjunaproject [8]. Therefore, it shares many of the same requirements:â€¢easy to learn and use: the interface to the simulation library should be easy tounderstand.â€¢correct abstraction: existing Java programmers should not find the simulationparadigm in conflict with the programming paradigm presented by Java. Simulationprogrammers used to other environments should find the transition to JavaSimstraightforward.â€¢flexible and extensible: it should be relatively easy for anyone to add newfunctionality to the system, such as new distribution functions.â€¢efficiency: the system should be efficient and produce efficient simulation runs.Simulation packages which we have experience of tended to be extremely slow andconsume large amounts of system resources.These requirements were realised in the following design decisions:â€¢the discrete-event process based simulation facilities provided by SIMULA [1][2]and its simulation classes and libraries have a considerable experience and usercommunity which have found them to be successful for a wide variety ofsimulations. In later versions of the system additional simulation classes were addedwhich provide extra functionality.1â€¢inheritance was to be used throughout the design to even a greater extent than isalready provided in SIMULA. This enables JavaSim to be more flexible andextensible, allowing new functionality to be added without affecting the overallsystem structure. For example, our I/O facilities, random number generators andprobability distribution functions are entirely object-oriented, relying on inheritanceto specialise their behaviour.1.1 AvailabilityJavaSim has been tested with JDK 1.0.2 and 1.1.x on Solaris, linux, and Windows 95/NT 4.0.Technical questions about JavaSim can be sent to M.C.Little@ncl.ac.uk.                                                

1It is not necessary for the reader to know anything about the SIMULA programming language or its simulationclasses, but such knowledge would aid in the understanding of the concepts and classes presented within.




The JavaSim Userâ€™s Manuals2. IntroductionThis manual is not intended as a tutorial on the concepts of simulation in general, but ratherhow to write simulations in the JavaSim system. However, in order to be able to do thiscertain key simulation concepts will be briefly described. The interested reader is referred to[6] for detailed descriptions of these concepts and for further discussions on simulationmodelling.2.1 Simulation modelsTo model a system is to replace it by something which is:â€¢simpler and/or easier to study.â€¢equivalent to the original in all important respects.Therefore, before constructing the actual simulation, it is first necessary to abstract from thereal system those components and their interactions that are considered important for theactual model. Building a simulation system model involves making certain simplifyingassumptions to aid in the actual implementation and study of the simulation (without suchsimplifications the model would be as complex as the system it is meant to be simulating).However, the accuracy of the results obtained from the simulation depend upon how valid theinitial assumptions are. For example, when considering the trajectory of a projectile throughthe atmosphere, the friction due to the air molecules is usually ignored. This assumption isvalid only within certain boundaries: if the size of the projectile is on the same scale as the airmolecules and its speed is sufficiently small then friction plays a significant role in itsmovement.Thus, the first step towards building a simulation model of a system is to determine exactlywhat are the important features which are to be measured, and what characteristics of thesystem have an affect on them. Any boundary conditions for the simulation (e.g., size ofprojectile) should be considered at the same time in order to simplify this procedure. Buildinga final model can often take several phases, where results from the initial model are comparedwith those obtained from the real system to determine their accuracy. Any discrepancies aretaken into account by possibly adding new components to the simulation until, within certainerror boundaries, the simulation results match those from the real system.2.2 TerminologyThe system components chosen for the simulation are termed simulation entities. Associatedwith each entity in the simulation are zero or more attributes that describe the state of theentity and which may vary during the course of the simulation. The interaction of entities andthe changes they cause in the system state are termed events.The collection of these component attributes at any given time t defines the system state at t.In general, the system state can take any of a variety of values, and a given simulation runresults in one realisation of a set of these values (the operation path) over the observationperiod.




The JavaSim Userâ€™s Manuals2.3 Categories of simulation modelsThere are three categories of simulation model, described by the way in which the systemstate changes as a function of time:â€¢Continuous time: is one whose state varies continuously with time; such systems areusually described by sets of differential equations.â€¢Discrete time: the system is considered only at selected moments in time (theobservation points). These moments are typically evenly spaced. Some economicsmodels are examples of this, where economics data becomes available at fixedintervals. Changes in state are noticed only at observation points. By choosing asuitably small interval between observation points, a continuous time simulation canbe approximated by a discrete time simulation.â€¢Continuous time-discrete event: the time parameter is (conceptually) continuous andthe observation period is a real interval, usually starting at zero for simplicity. Theoperation path is completely determined by the sequence of event times (which neednot be evenly spaced and can be of arbitrary increments) and by the discrete changesin the system state which take place at these times (i.e., the interactions of theevents). In between consecutive event times the system state may vary continuously.Although it is possible to model the passage of real time by suitable event timing,this is not necessary for a discrete event system: the simulation model can advanceits own internal time directly from one discrete event to another, taking anyappropriate action to advance the state accordingly.It is this latter category of simulation modelling that JavaSim supports. Examples of discrete-event simulations are most queuing problems: entities (e.g., customers in a bank) arriveaccording to a given distribution and change the system state instantaneously (e.g., thenumber of customers in the queue). The operation paths for this system are step functions:they jump up (or down) by one when a customer joins (or leaves) the queue.2.4 Event schedulingGiven that a simulation consists of a series of interacting events (the operation path), asimulator can be defined as that program devoted to the generation of operation paths. Thesimulator allows the creation of events and controls their interactions according to a set ofrules, using an internal â€œclockâ€ to keep track of the passage of (simulation) time.It maintains an event list, which indicates which events are to be scheduled for execution atspecific simulation times. Events are executed according to their simulation times. There aretwo approaches to the way in which a simulator can schedule events to produce an operationpath:â€¢event-oriented: there is a procedure associated with each type of event in the system:it performs the action required to handle that type of event and it is invoked everytime such an event occurs. In an event�oriented approach, an operation path isobtained by taking a global view of everything that happens in the system; themanipulation of events is explicit.â€¢process-oriented: an operation path is obtained by the interacting of a number ofprocesses running in parallel. The management of events is implicit in themanagement of the processes. The simulation system provides primitives for placingprocesses at particular points on the event list, removing and re�scheduling them.




The JavaSim Userâ€™s ManualsThe process-oriented approach best fits with the object-oriented paradigm which we want topresent to the programmer of JavaSim. As in SIMULA, simulation processes then becomeactive objects which interact with each other through message passing and the simulationprimitives. Refinements of these objects can then be obtained by inheriting from them andredefining the appropriate methods.




The JavaSim Userâ€™s Manuals3. Basic simulation classesThis chapter describes the core elements of the JavaSim simulation system. It is not intendedas a tutorial on Java, and basic knowledge of the language is assumed. Note, all of the classesdescribed in this section can be found in the arjuna.JavaSim.Simulation package.3.1 The simulation schedulerChapter 2 described the event list and how simulation entities (processes) are executedaccording to their position on the event list (i.e., with increasing simulation time). In JavaSim,as in SIMULA, simulation processes are managed by a scheduler and are placed on ascheduler queue (the event list). Processes are executed in pseudo-parallel, i.e., only oneprocess executes at any instance of real time, but many processes may execute concurrently atany instance of simulation time. The simulation clock is only advanced when all processeshave been executed for the current instance of simulation time.Inactive processes are placed on to the scheduler queue, and when the current active processyields control to the scheduler (either because it has finished or been placed back onto thescheduler queue), the scheduler removes the process at the head of the queue and re-activatesit.2 When the scheduler queue is empty, i.e., there are no further processes left to execute, thescheduler terminates the simulation.

t1t2t2t3t0Active ProcessSchedulerScheduler Queue

Figure 1: Scheduler-Process InteractionAs Figure 1 shows, the scheduler co-ordinates the entire simulation run, effectivelymonitoring the active and passive processes to enable it to determine when, and which,process to activate next. A simulation application cannot affect the scheduler directly, but cando so only indirectly through modifications of the scheduler queue.Note: the scheduler queue can be structured in a variety of ways, including a linear list or atree. The implementation of the queue can depend upon the type of simulation beingconducted. For example, a simulation which involves many (concurrent) processes wouldsuffer from using a linear ordered queue which would typically have insertion and removalroutines with overheads proportional to the number of entries in the queue. However, a linear                                                

2In SIMULA the currently active process is not removed from the head of the queue.




The JavaSim Userâ€™s Manualslist may work best for a low number of simulation processes. JavaSim comes with a suite ofscheduler queue implementations which can be chosen when the system is built.3.1.1 Scheduler class interfaceThe scheduler is an instance of the Scheduler class. It is the responsibility of theapplication programmer to ensure that only a single instance of this class is created.public class Scheduler

{

    public static double CurrentTime ();

    public static synchronized void reset ();

    public static synchronized boolean simulationReset ();

    public static synchronized void startSimulation ();

};

The scheduler maintains the simulation clock, and the current value of this clock is obtainedby invoking the CurrentTime() method.To enable multiple simulation runs to occur within a single application, it is possible to resetthe scheduler and simulation clock by calling the reset() method. This causes thescheduler to remove all processes (simulation objects) currently registered on the schedulerqueue and to invoke a class specific method on each of them which resets their states(detailed in the next section). Once this is finished the simulation is ready for an additionalrun. A suspended process is informed that it has been â€œresetâ€ by having the method it calledto originally suspend itself (i.e., place itself on the scheduler queue) raise theRestartSimulation exception, which the object should catch. It must then perform anywork necessary to put itself back in a state ready for restarting the simulation, and should thensuspend itself again before the simulation can be restarted (typically by calling Cancel.)3.2 Simulation processesAs was described in the previous chapter, JavaSim supports the process�oriented approach tosimulation, where each simulation entity can be considered a separate process. Therefore inJavaSim the entities within a simulation are represented by process objects. These are Javaobjects which have an independent thread of control associated with them at creation time,allowing them to convey the notion of activity necessary for participating in the simulation.In keeping with the object�oriented paradigm, and to make development of process objectssimpler, classes inherit the process functionality from the appropriate base class (Process).This class defines all of the necessary operations for the simulation system to control thesimulation entities within it, and for them to interact with it and each other.At any point in simulation time, a process can be in one (and only one) of the followingstates:â€¢active: the process has been removed from the head of the scheduler queue and itsactions are being executed.â€¢suspended: the process is on the scheduler queue, scheduled to become active at aspecified simulation time.â€¢passive: the process is not on the scheduler queue. Unless another process brings itback on to the queue it will not execute any further actions.




The JavaSim Userâ€™s Manualsâ€¢terminated: the process is not on the scheduler queue and has no further actions toexecute. Once a process has been terminated it cannot be made to execute further inthe same simulation run.A process which is either active or suspended is said to be scheduled.3.2.1 SimulationProcess class interfaceThe SimulationProcess class definition is shown below. Before considering how tobuild an example class derived from SimulationProcess we shall discuss the methodswhich it provides.Because the constructors are protected, it is not possible to create an instance of theSimulationProcess class, i.e., classes must be derived from this. Processes are threadedobjects, and typically each thread package schedules execution of threads according to apriority. By default, all processes in JavaSim are created with the same priority, but this canbe altered by calling the setPriority method of java.lang.Thread. Note, however,that priorities have no effect on a simulation run.public class SimulationProcess extends Thread

{

public final double Time ();

public synchronized SimulationProcess next_ev ()

                        throws SimulationException, NoSuchElementException;




The JavaSim Userâ€™s Manualspublic final double evtime ();

public void ActivateBefore (SimulationProcess p)

                              throws SimulationException, RestartException;

public void ActivateAfter (SimulationProcess p) throws SimulationException,

                                                       RestartException;

public void ActivateAt (double AtTime, boolean prior)

                                   throws SimulationException,

                                          RestartException;

public void ActivateAt (double AtTime) throws SimulationException,

                                              RestartException;

public void ActivateDelay (double Delay, boolean prior)

                                   throws SimulationException,

                                          RestartException;

public void ActivateDelay (double Delay) throws SimulationException,

                                                RestartException;

public void Activate () throws SimulationException, RestartException;

public void ReActivateBefore (SimulationProcess p)

                              throws SimulationException, RestartException;

public void ReActivateAfter  (SimulationProcess p)

                              throws SimulationException, RestartException;

public void ReActivateAt (double AtTime, boolean prior)

                                   throws SimulationException,

                                          RestartException;

public void ReActivateAt (double AtTime) throws SimulationException,

                                                RestartException;

public void ReActivateDelay (double Delay, boolean prior)

                                   throws SimulationException,

                                          RestartException;

public void ReActivateDelay (double Delay) throws SimulationException,

                                                  RestartException;

public void ReActivate () throws SimulationException, RestartException;

public void Cancel () throws RestartException;

public void terminate ();

public synchronized boolean idle ();

public boolean passivated ();

public boolean terminated ();

public static SimulationProcess current () throws SimulationException;

public static double CurrentTime ();

public static void mainSuspend ();

public static void mainResume () throws SimulationException;

protected SimulationProcess ();

protected void set_evtime (double time) throws SimulationException;

protected void Hold (double t) throws SimulationException,

                                      RestartException;

protected void Passivate () throws RestartException;

protected void Suspend () throws RestartException;

protected void Resume ();

};

There are five ways to activate a currently passive process, which results in it being broughtto the correct position in the scheduler queue corresponding to its associated simulation time.If this is the head of the queue then it will become the active process.




The JavaSim Userâ€™s Manualsâ€¢Activate(): this activates the process at the current simulation time.â€¢ActivateBefore(SimulationProcess proc): this positions the processin the scheduler queue before proc, and gives it the same simulation time. If procis not present then a SimulationException will be thrown.â€¢ActivateAfter(SimulationProcess proc): this positions the process inthe scheduler queue after proc, and gives it the same simulation time. If proc isnot present then a SimulationException will be thrown.â€¢ActivateAt(double AtTime, boolean prior): the process is insertedinto the scheduler queue at the position corresponding to the simulation timespecified by AtTime. The default for this time is the current simulation time. Theprior parameter is used to determine whether this process should be insertedbefore or after any processes with the same simulation time which may already bepresent in the queue. The default is false.â€¢ActivateDelay(double AtTime, boolean prior): the process isactivated after a specified delay (AtTime). The process is inserted into the queuewith the new simulation time, and the prior parameter is used to determine itsordering with respect to other processes in the queue with the same time. The defaultis false.There are correspondingly five ReActivate methods, which work on either passive orscheduled processes. These will not be described in detail as they have similar signatures totheir Activate counterparts and work in the same way.Hold(double period) schedules the currently active process for re-activation after thesimulated delay of period time. If this is invoked by the object (e.g., through a publiclyavailable method) when it is not the current active process then it does nothing.evtime() returns the time at which the process is scheduled for activation.next_ev() returns a reference to the next process to be scheduled for execution. If thequeue is empty then null is returned.The static method current() returns a reference to the currently active process.The current simulation time can be obtained by using either the CurrentTime() orTime() methods. The former method is static and as such can be invoked without aninstance of the SimulationProcess class.Cancel() removes the process from the scheduler queue or suspends it if it is the currentlyactive process. In either case, the process is set to the passive state. Passivate() functionssimilarly but only works on the currently active process, i.e., if it is invoked by the object(e.g., through a publicly available method) when it is not the current active process then itdoes nothing.terminate() removes the process from the scheduler queue or it is suspended if it iscurrently active. The process is then set to the terminated state, and can take no further part inthis simulation run.idle() returns false if the process is either active or scheduled to become active.Otherwise true is returned.




The JavaSim Userâ€™s Manualspassivated() and terminated() indicate whether the process is in the passive orterminated state, respectively.Because SimulationProcess extends the java.lang.Thread class it is necessaryfor the simulation class to provide an implementation of the run method which will do theactual work for the process. If this method ever returns then the thread is destroyed. However,in order for JavaSim to detect the termination of the thread, the terminate() method mustbe used instead.3.2.2 ExampleTo illustrate how a simulation process could be implemented from the Process class weshall consider the example of a queue of customers arriving at a bank. For this example, thisinvolves three classes:â€¢Customer: instances of this class represent the customers in the queue.â€¢Queue: the instance of this class (queue) is the queue into which customers areplaces.â€¢Arrivals: this is the process which creates new customers for insertion in queue.The implementations of the Customer and Queue classes are not important to thisexample. The implementation of the Arrivals class could be:class Arrivals : public Process

{

public:

    Arrivals () {};

    ~Arrivals () {};

    void Body ();

};

void Arrivals::Body ()

{

    for (;;)

    {

        Customer* c = new Customer();

        queue.insert(c);

        Hold(20.0);

    }

}

3.3 Starting, ending and controlling a simulationWhen a SimulationProcess object is created in JavaSim it starts in the passive state,and must be activated before it can take part in the simulation. This is typically performed bythe first process object to which control is transferred after the simulation is initially started.When writing JavaSim applications it is typical for the main thread to create a singlecontroller process which is responsible for co-ordinating the entire simulation run. Thiscreates and activates all of the simulation entities and the scheduler, and provides methods forsuspending the main thread, thus allowing the controller object to execute, and exiting theapplication. An example controller interface is shown below, and the implementations for itsmethods will be described in the following sections:




The JavaSim Userâ€™s Manualspublic class Controller extends SimulationProcess

{

public Controller ();

public void run ();

public void await ();

public void exit ();

};

Because Controller is a simulation process itself, it derives from Simulationrocessand defines a run() method, which will do the actual controlling of the simulation. It alsoprovides the following methods:â€¢await(): this method is called within the main application thread and suspends it,effectively transferring control the Controller process.â€¢exit(): this method is called to exit the simulation.3.3.1 Suspending the main threadWhen a threaded application is started it is important to realise that before any applicationthreads are created, the Java virtual machine has already created one to run the application.This thread must be suspended before any simulation threads can run.The await() method of Controller is responsible for suspending this thread:public void await ()

{

    Resume();

    SimulationProcess.mainSuspend();

}

It must first resume the thread associated with the Controller instance (sinceController is a SimulationProcess it starts in the passive state). This thread doesnot execute until the main thread is suspended by the call to the static mainSuspendmethod.The code for main would then become:public static void main (String[] args)

{

    Controller c = new Controller();

    c.await();

}

3.3.2 Exiting the applicationIn order to exit a simulation application, the application can call System.exit. However,if it is only necessary to resume the main thread, then this can be accomplished by using thestatic mainResume method of the SimulationProcess class. Once the main thread hasbeen resumed, it will continue to execute from the point it was suspended. In the exampleabove, this would be from within the await method. The thread which calls mainResumecan then suspend or terminate itself, depending upon the application requirements.




The JavaSim Userâ€™s Manualspublic void exit ()

{

    if (resumeMainRequired)

    {

        SimulationProcess.mainResume();

        Suspend();

    }

    else

        System.exit(0);

}

3.3.3 Controlling the simulationThe controllerâ€™s body creates and activates the other simulation entities and the scheduler, andcontrols the overall simulation (e.g., resetting the system between consecutive runs).public void run ()

{

    sc = new Scheduler();

    // create and activate any other simulation entities

    sc->Resume();  // we must create a scheduler for the simulation to run

    // execute the simulation

    // print results

    sc->Suspend();  // suspend scheduler

    // suspend simulation entities

    Thread_Type::mainResume();

}

The final call to mainResume prevents run() from exiting, which we must do to ensurethe application is portable between thread implementations.3.4 Resetting a simulationResetting a simulation involves resetting all of the objects involved in it which will berequired for subsequent runs. When the reset method is invoked on the Scheduler, this causesthe current simulation run to be terminated, and all simulation objects which are currentlysuspended on the scheduler queue will be woken and the RestartException will bethrown to each. Any objects which are required to participate within a new simulation runmust catch this exception, reset themselves to a state consistent with the start of anothersimulation, and then become suspended, to await the restart of the simulation.




The JavaSim Userâ€™s Manuals3.4.1 ExampleIf we take the Arrivals example above and add a reset method then the code could be:public class Arrivals extends SimulationProcess

{

public void run ()

{

    for (;;)

    {

        try

        {

            for (;;)

            {

                Customer c = new Customer();

                queue.insert(c);

                Hold(20.0);

            }

        }

        catch (RestartException e)

        {

        }

    }

}

};




The JavaSim Userâ€™s Manuals4. Distribution FunctionsMany of the aspects of the real world which a simulation attempts to model have propertieswhich correspond to various distribution functions, e.g., inter-arrival rates of customers at abank queue. Therefore, simulation studies require sources of random numbers. Ideally thesesources should produce an endless stream of such numbers, but to do so either requiresspecialised hardware or the ability to store an infinite (large) table of such numbers generatedin advance.Without such aids, which are either impractical or not generally available, the alternative is touse numerical algorithms. No deterministic algorithm can produce a sequence of numbers thatwould have all of the properties of a truly random sequence [3]. However, for all practicalpurposes it is only necessary that the numbers produced appear random, i.e., pass certainstatistical tests for randomness. Although these generators produce pseudo-random numbers,we continue to call the random number generators.The starting point for generating arbitrary distribution functions is to produce a standarduniform distribution. As we shall see, all other distributions can be produced based upon this.(Interested readers are referred to [6] for a more complete treatment of this topic). All of thedistribution functions in JavaSim rely upon inheritance to specialise the behaviour obtainedfrom the uniform distribution class. These classes can be found in thearjuna.JavaSim.Distributions package.4.1 RandomStreamThe actual uniform distribution class is called RandomStream. This returns a series ofrandom numbers uniformly distributed between 0 and 1. We experimented with severalrandom number generators before settling on a shuffle of a multiplicative generator with alinear congruential generator, which provides a reasonably uniform stream of pseudo-randomnumbers.public abstract class RandomStream

{

public abstract double getNumber () throws IOException,

ArithmeticException;

public final double Error ();

protected RandomStream ();

protected RandomStream (long MGSeed, long LCGSeed);

protected final double Uniform ();

};

The multiplicative generator uses the following algorithm3:Y[i+1] = Y[i] * 55 mod 226, where the period is 224, and the initial seed must be odd.                                                

3Thanks to Professor I. Mitrani for his help in developing this.




The JavaSim Userâ€™s ManualsThe Uniform() method uses the linear congruential generator (seed is LCGSeed, with thedefault value of 1878892440L) based on the algorithm in [4], and the results of this areshuffled with the multiplicative generator (see is MGSeed, with a default value of 772531L)as suggested by Maclaren and Marsaglia [3], to obtain a sufficiently uniform randomdistribution, which is then returned.The Error() method returns a chi-square error measure on the uniform distributionfunction.By abstract method getNumber must be provided by derived classes, and is used to obtain auniform means of accessing random numbers.The RandomStream class returns a large sequence of random numbers, whose period is2^24. However, unless the seeds are modified when each random distribution class is created,the starting position in this sequence will always be the same, i.e., the same sequence ofnumbers will be obtained. To prevent this, each class derived from RandomStream has anadditional parameter for one of its constructors which indicates the offset in this sequencefrom which to begin sampling.4.2 UniformStreamThe UniformStream class inherits from RandomStream and returns random numbersuniformly distributed over a range specified when the instance is created.public class UniformStream extends RandomStream

{

public UniformStream (double lo, double hi);

public UniformStream (double lo, double hi, int StreamSelect);

public UniformStream (double lo, double hi, int StreamSelect,

                      long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};

The range covers the interval specified by lo and hi. StreamSelect indicates the offsetin the random number sequence to begin sampling, and MGSeed and LCGSeed can be usedto modify the seed values used by the RandomStream class.4.3 ExponentialStreamThe ExponentialStream class returns an exponentially distributed stream of randomnumbers with mean value specified by mean.public class ExponentialStream extends RandomStream

{

public ExponentialStream (double mean);

public ExponentialStream (double mean, int StreamSelect);

public ExponentialStream (double mean, int StreamSelect,

  long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};




The JavaSim Userâ€™s ManualsStreamSelect indicates the offset in the random number sequence to begin sampling, andMGSeed and LCGSeed can be used to modify the seed values used by the RandomStreamclass.4.4 ErlangStreamErlangStream returns an erlang distribution with mean mean and standard deviation sd.public class ErlangStream extends RandomStream

{

public ErlangStream (double mean, double sd);

public ErlangStream (double mean, double sd, int StreamSelect);

public ErlangStream (double mean, double sd, int StreamSelect,

           long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};

StreamSelect indicates the offset in the random number sequence to begin sampling, andMGSeed and LCGSeed can be used to modify the seed values used by the RandomStreamclass.4.5 HyperExponentialStreamThe HyperExponential class returns a hyper-exponential distribution of randomnumbers, with mean mean and standard deviation sd.public class HyperExponentialStream extends RandomStream

{

public HyperExponentialStream (double mean, double sd);

public HyperExponentialStream (double mean, double sd, int StreamSelect);

public HyperExponentialStream (double mean, double sd, int StreamSelect,

       long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};

StreamSelect indicates the offset in the random number sequence to begin sampling, andMGSeed and LCGSeed can be used to modify the seed values used by the RandomStreamclass.4.6 NormalStreamNormalStream returns a normal distribution of random numbers, with mean mean andstandard deviation sd. operator() uses the polar method due to Box, Muller, andMarsaglia [3].public class NormalStream extends RandomStream

{

public NormalStream (double mean, double sd);

public NormalStream (double mean, double sd, int StreamSelect);

public NormalStream (double mean, double sd, int StreamSelect,

         long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};




The JavaSim Userâ€™s ManualsStreamSelect indicates the offset in the random number sequence to begin sampling, andMGSeed and LCGSeed can be used to modify the seed values used by the RandomStreamclass.4.7 DrawThe Draw class is the exception to the inheritance rule, instead using RandomStreamthrough delegation (for historical reasons). This returns true with the probability prob, andfalse otherwise.public class Draw

{

public Draw (double p);

public Draw (double p, int StreamSelect);

public Draw (double p, int StreamSelect, long MGSeed, long LCGSeed);

public boolean getBoolean () throws IOException;

};

StreamSelect indicates the offset in the random number sequence to begin sampling, andMGSeed and LCGSeed can be used to modify the seed values used by the RandomStreamclass.4.8 Example




The JavaSim Userâ€™s Manuals5. Advanced Simulation ClassesSimulations formed by the interaction of objects derived from SimulationProcess canbe considered causal (synchronous) in nature: events occur at specific times and form a welldefined order. However, it is sometimes necessary to simulate asynchronous real worldevents, e.g., processor interrupts. To do this requires finer-grained control of the schedulingof simulation processes than it provided by the scheduler; the scheduler simply activatesaccording to simulation time, whereas asynchronous events may have different activationrules, e.g., activate when another process is terminated.The SimulationEntity class and others to be described in the following sections givesthis required level of control to the user, extending the types of simulation which are possiblewith JavaSim. Asynchronous simulation processes are derived from SimulationEntity,but the implementation enables these asynchronous process to execute in the same simulationas SimulationProcess objects. However, because these processes are suspended andresumed outside of the control of the scheduler, it is possible for deadlock situations to occur.Therefore, some care must be taken when using these classes.In addition to the active, suspended, passive and terminated states which a simulation processcan be in, asynchronous objects can also be in the following states:â€¢waiting: the process is suspended waiting for a specific event to occur (e.g., aprocess to be terminated). The waiting process is not placed on the scheduler queue.â€¢interrupted: the process, which was in the waiting state, has been interrupted fromthis before the condition it was awaiting occurred.The conditions on which a process can wait, and can thus be interrupted from, are:â€¢time: a process can attempt to wait for a specified period of simulation time.â€¢process termination: a process can wait for the termination of anotherSimultionEntity process before continuing execution.â€¢semaphore: critical regions of a simulation can be protected by semaphores, whereonly a single Entity process can acquire the semaphore; other processes aresuspended until the semaphore is released.â€¢user specific: it is possible for other asynchronous conditions to occur which are notcovered above.The classes to be described in this chapter can be found in thearjuna.JavaSim.Simulation package.




The JavaSim Userâ€™s Manuals5.1 Asynchronous entitiespublic class SimulationEntity extends SimulationProcess

{

public void Interrupt (SimulationEntity toInterrupt, boolean immediate)

                              throws SimulationException, RestartException;

public final void trigger ();

public void terminate ();

protected SimulationEntity ();

protected void Wait (double waitTime) throws SimulationException,

                                    RestartException, InterruptedException;

protected void WaitFor (SimulationEntity controller, boolean reAct)

                                 throws SimulationException,

                                    RestartException, InterruptedException;

protected void WaitFor (SimulationEntity controller)

                                 throws SimulationException,

                                    RestartException, InterruptedException;

protected void WaitForTrigger (TriggerQueue _queue)

                                 throws SimulationException,

                                    RestartException, InterruptedException;

protected void WaitForSemaphore (Semaphore _sem) throws RestartException;

};

Because SimulationEntity is derived from SimulationProcess, all of the usualsimulation methods are available, and can be used in conjunction with those provided by thederived class.Interrupt(SimulationEntity toInterrupt, boolean immediate)interrupts the asynchronous process toInterrupt, which must not be terminated andmust be in the waiting state. toInterrupt becomes the next active process (i.e., it ismoved to the head of the scheduler queue). If immediate is true then the current process issuspended immediately; it is scheduled for reactivation at the current simulation time.Otherwise, the current process continues to execute and can be suspended later in anapplication specific way.Because it is now possible for one process to wait for another to terminate theterminate() method must differ from that provided by SimulationProcess. Beforethe terminating process ends it moves the waiting process to the head of the scheduler queue,and then calls SimulationProcess.terminate(). Currently only a single processcan wait on this termination condition, but this may change in future versions.Wait(double t) is similar to Hold(double t), with the exception that the process ismoved into the waiting state as well as being placed on the scheduler queue. It is thereforepossible to interrupt this process before the wait period has elapsed. true is returned if theprocess was interrupted, otherwise false is returned.WaitFor(SimulationEntity controller, boolean reAct) suspends thecurrent process until controller has terminated. The process is placed in the waitingstate. If reAct is true then controller is moved to the head of the scheduler queue tobecome the next activate process, otherwise (the default behaviour) the application will haveto activate controller. If the waiting process is interrupted then the method returns




The JavaSim Userâ€™s Manualstrue, otherwise false. The controller and the current process must be different, i.e.,it is not possible for a process to wait for itself.Trigger queues are lists maintained by the simulation system of process waiting for specificevents to occur, which are outside the scope of those described above. These will bedescribed in the next section. WaitForTrigger(TriggerQueue queue) places thecurrent process on the trigger queue _queue, and passivates it. As with the previousmethods, the return value indicates whether the process was interrupted, or triggered.In addition to trigger queues, process can wait on semaphores, allowing the creation ofmonitor regions, for example. WaitForSemaphore(Semaphore sem) causes thecurrent process to attempt to exclusively acquire the semaphore. If this is not possible thenthe process is suspended. Currently, a process which is waiting on a semaphore cannot beinterrupted, and is not placed into the waiting state. As such, when this method returns thesemaphore has been acquired.5.2 Trigger queuesProcesses waiting for the same application controlled event can be grouped together into aTriggerQueue, as described in the previous section. When this event occurs theapplication can use one of the two trigger methods to activate the queue members. Thisinvolves placing the process(es) onto the head of the scheduler queue.public class TriggerQueue

{

public TriggerQueue ();

public void finalize ();

public synchronized void triggerFirst (boolean setTrigger)

                                             throws NoSuchElementException;

public synchronized void triggerFirst () throws NoSuchElementException;

public synchronized void triggerAll () throws NoSuchElementException;

};

â€¢triggerAll(): triggers all of the members on the queue.â€¢triggerFirst(boolean setTrigger): triggers only the head of the queue.If setTrigger is true (the default behaviour) then the trigger() method ofthe SimulationEntity object is also invoked.If the queue is not empty when it is garbage collected by the virtual machine then allremaining queue members will be triggered, and placed back onto the scheduler queue.




The JavaSim Userâ€™s Manuals5.3 SemaphoresApplication code can be protected from simulation processes through semaphores, which areinstances of the Semaphore class.public class SemaphoreOutcome

{

    static final public int DONE = 0;

    static final public int NOTDONE = 1;

    static final public int WOULD_BLOCK = 2;

};

public class Semaphore

{

public Semaphore ();

public Semaphore (long number);

public synchronized long NumberWaiting ();

public synchronized int Get (SimulationEntity toWait)

                                                   throws RestartException;

public synchronized int TryGet (SimulationEntity toWait)

                                                   throws RestartException;

public synchronized int Release ();

};

A semaphore can be used to restrict the number of processes which can use shared resources.The number of shared resources available must be presented to the Semaphore when it iscreated. By default, a Semaphore will assume that there is only a single resource, in whichcase a semaphore is exclusively acquired by a simulation process. However, it is possible tocreate a Semaphore with different resource counts.A Semaphore can exist in one of two states:â€¢available: the semaphore is available to be acquired.â€¢unavailable: a process (or number of processes) currently has the semaphore. Ifanother process attempts to acquire the semaphore then it is automatically suspendeduntil the semaphore is available, i.e., until a resource has been freed.To be able to manipulate semaphores, a process must be derived from theSimulationEntity class. To obtain the semaphore, the Get(SimulationEntitytoWait) method should be used, where toWait is the calling process. If the semaphore isunavailable then the process referenced by toWait is suspended. If the semaphore issuccessfully acquired, then SemaphoreOutcome.DONE is returned, otherwiseSemaphoreOutcome.NOTDONE.If the process wishes to attempt to acquire the semaphore but does not want to block in thesituation where the semaphore is currently unavailable, then it can use the TryGet method,which takes the same parameter as Get. However, unlike Get, TryGet will returnSemaphoreOutcome.WOULD_BLOCK in the case where the caller would normally blockif it had called Get, i.e., the semaphore is currently in use. If the semaphore is not being used,then TryGet will acquire it for the caller. Errors will result inSemaphoreOutcome.NOT_DONE being returned.When the semaphore is no longer required Release() should be called by the processwhich currently has it. Successful release of the semaphore results in




The JavaSim Userâ€™s ManualsSemaphoreOutcome.DONE being returned, otherwise Semaphore.NOTDONE isreturned.NumberWaiting() returns the number of processes currently suspended waiting for thesemaphore.If the semaphore is garbage collected with processes waiting for it then an error message isdisplayed. No further action is attempted on behalf of these waiting processes.5.4 Example




The JavaSim Userâ€™s Manuals6. Statistical ClassesThe purpose of a simulation typically involves the gathering of relevant statisticalinformation, e.g., the average length of time spent in a queue. JavaSim provides a number ofdifferent classes for gathering such information. These classes can be found in thearjuna.JavaSim.Statistics package.6.1 MeanThis is the basic class from which others are derived, gathering statistical information on thesamples provided to it.public class Mean

{

public Mean ();

public void setValue (double value) throws IllegalArgumentException;

public void reset ();

public int numberOfSamples ();

public double min ();

public double max ();

public double sum ();

public double mean ();

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

public void print ();

};

New values can be supplied to the instance of the Mean class using thesetValue(double) method. The number of samples which have been give can beobtained from numberOfSamples().The maximum and minimum of the samples supplied can be obtained from the max() andmin() methods, respectively.sum() returns the summation of all of the samples:SSii=1nmean() returns the mean value:SSii=1n1_nAn instance of Mean can be reset between samples using the reset() method.




The JavaSim Userâ€™s ManualsIf the state of a Mean object is required to be saved between simulation runs then it can bemade persistent by using either of the saveState methods. The first instance saves thestate to a file, whereas the second can be used to save the state to an instance of thejava.io.DataOutputStream class. There are likewise two corresponding ways inwhich the state can be restored.The print method simply prints to System.out the current state of the object.6.2 VarianceThis class is derived from Mean, and in addition to providing the above mentionedfunctionality also provides the following:public class Variance extends Mean

{

public Variance ();

public void setValue (double value) throws IllegalArgumentException;

public void reset ();

public double variance ();

public double stdDev ();

public double confidence (double value);

public void print ();

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

};

variance() returns the variance of the samples:Si=1n1_n(Si-Mean())2stdDev() returns the standard deviation of the samples, which is the square root of thevariance.6.3 TimeVarianceThe TimeVariance class makes it possible to determine how long, in terms of simulationtime, specific values were maintained. In effect, values are weighted according to the lengthof time that they were held, whereas with the Variance class only the specific values aretaken into account.




The JavaSim Userâ€™s Manualspublic class TimeVariance extends Variance

{

public TimeVariance ();

public void reset ();

public void setValue (double value) throws IllegalArgumentException;

public double timeAverage ();

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

};

Whenever a value is supplied to an instance of the TimeVariance class the simulationtime at which it occurred is also noted. If a value changes, or the timeAverage() methodis invoked, then the time it has been maintained for is calculated and the statistical data isupdated.6.4 HistogramsMean, Variance, and TimeVariance provide a snapshot of values in the simulation.However, histograms can yield better information about how a range of values change overthe course of a simulation run. This information can be viewed in a number of ways, buttypically it is plotted in graphical form.A histogram typically maintains a slot for each value, or range of values, given to it. Theseslots are termed buckets, and the way in which these buckets are maintained and manipulatedgives rise to a variety of different histogram implementations. The following sections detailthis variety of different histogram classes.6.4.1 PrecisionHistogramThe PrecisionHistogram class represents the core histogram class from which allothers are derived. This class keeps an exact tally of all values given to it, i.e., a bucket iscreated for each value. Although buckets are only created when requires, over the course of asimulation this can still utilise a large amount of resources, and so other, less precise,histogram classes are provided.




The JavaSim Userâ€™s Manualspublic class PrecisionHistogram extends Variance

{

public PrecisionHistogram ();

public void finalize ();

public void setValue (double value) throws IllegalArgumentException;

public void reset ();

public long numberOfBuckets ();

public double sizeByIndex (long index) throws StatisticsException,

                                              IllegalArgumentException;

public double sizeByName (double name) throws IllegalArgumentException;

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

public void print ();

};

As with the Variance class from which it is derived, and whose methods are obviouslyavailable, values can be supplied to the histogram through the setValue(double)method.The number of buckets maintained by the histogram can be obtained from thenumberOfBuckets() method. Each bucket is uniquely named by the values it contains,and can also be accessed by its index in the entire list of buckets.There are therefore two ways of getting the number of entries in a bucket:â€¢by the index number of the bucket: sizeByIndex(long index).â€¢by the unique name of the bucket: sizeByName(double name).If the bucket does not exist then each of these methods throwsIllegalArgumentException.It is possible to output the contents of the histogram to standard output using theprint()method.6.4.2 HistogramThe problem with the PrecisionHistogram class is that it can use up a lot of systemresources, especially over the course of a long simulation. Histogram attempts to alleviatethis by presenting a histogram which is less accurate, but consumes less resources. Instead ofmaintaining a bucket for each individual value, it keeps a fixed number of buckets. Initiallyeach bucket will store separate values as in the PrecisionHistogram, but when thenumber of required buckets would exceed the specified maximum number it merges pairs ofbuckets, thus reducing their total. The policy used when merging buckets it set on a perinstance basis when created. Current policies are:â€¢ACCUMULATE: create a new bucket with the same name as the largest of the twobuckets, and it has the sum of the two old bucket entries as its entry number.




The JavaSim Userâ€™s Manualsâ€¢MEAN: create a new bucket with the name as the mean of the two old buckets, and ithas the sum of the two old bucket entries as its entry number.â€¢MAX: create a new bucket with the name as the largest of the two buckets, and it hasthe same number of entries.â€¢MIN: create a new bucket with the name as the smallest of the two old buckets, andit has the same number of entries.public class Histogram extends PrecisionHistogram

{

public Histogram (long maxIndex, int mergeChoice);

public Histogram (long maxIndex);

public void setValue (double value) throws IllegalArgumentException;

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

public void print ();

};

When an instance of Histogram is created, the maximum number of allowed buckets mustbe specified. The merging algorithm can also be provided, with the default being the MEANpolicy.6.4.3 SimpleHistogramAs with the Histogram class above, SimpleHistogram keeps the number of assignedbuckets to a minimum. However, it does this by pre-creating the buckets when it is created,i.e., the number of required buckets must be provided at the start. A width is the assigned foreach bucket, and whenever a value if given to the histogram class it is placed into the bucketwhose width it falls within.public class SimpleHistogram extends PrecisionHistogram

{

public SimpleHistogram (double min, double max, long nbuckets);

public SimpleHistogram (double min, double max, double w);

public void setValue (double value) throws IllegalArgumentException;

public void reset ();

public double sizeByName (double name) throws IllegalArgumentException;

public double Width ();

public void print ();

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

};

When the class is instantiated, the range of values it will receive must be provided. Then,either the width of each bucket or the actual number of buckets can be given. If the width is




The JavaSim Userâ€™s Manualsprovided, then the histogram automatically calculates the number of buckets, otherwise itcalculates the width for each bucket by equally dividing the range between each bucket.The values of a bucket can be obtained from the sizeByName method.The width of each bucket is provided by the Width method.6.4.4 QuantileThe Quantile class provides a means of obtaining the p-quantile of a distribution of values,i.e., the value below which p-percent of the distribution lies.public class Quantile extends PrecisionHistogram

{

public Quantile ();

public Quantile (double q) throws IllegalArgumentException;

public double getValue ();

public double range ();

public void print ();

};

The p-quantile probability range must be specified when the object is instantiated, and can beobtained via the range method.The actual quantile value is provided by getValue method.




The JavaSim Userâ€™s Manuals7. JavaSim classesFor convenience, in this section we shall include the JavaSim classes which programmers willuse when constructing simulations.7.1 Schedulerpackage arjuna.JavaSim.Simulation;

public class Scheduler

{

    public static double CurrentTime ();

    public static synchronized void reset ();

    public static synchronized boolean simulationReset ();

    public static synchronized void startSimulation ();

};




The JavaSim Userâ€™s Manuals7.2 SimulationProcesspackage arjuna.JavaSim.Simulation;

public class SimulationProcess extends Thread

{

public final double Time ();

public synchronized SimulationProcess next_ev ()throws SimulationException,

                                                    NoSuchElementException;

public final double evtime ();

public void ActivateBefore (SimulationProcess p)throws SimulationException,

                                                        RestartException;

public void ActivateAfter (SimulationProcess p) throws SimulationException,

                                                       RestartException;

public void ActivateAt (double AtTime, boolean prior)

                              throws SimulationException, RestartException;

public void ActivateAt (double AtTime) throws SimulationException,

                                              RestartException;

public void ActivateDelay (double Delay, boolean prior)

                              throws SimulationException, RestartException;

public void ActivateDelay (double Delay) throws SimulationException,

                                                RestartException;

public void Activate () throws SimulationException, RestartException;

public void ReActivateBefore (SimulationProcess p)

                              throws SimulationException, RestartException;

public void ReActivateAfter  (SimulationProcess p)

                              throws SimulationException, RestartException;

public void ReActivateAt (double AtTime, boolean prior)

                              throws SimulationException, RestartException;

public void ReActivateAt (double AtTime) throws SimulationException,

                                                RestartException;

public void ReActivateDelay (double Delay, boolean prior)

                              throws SimulationException, RestartException;

public void ReActivateDelay (double Delay) throws SimulationException,

                                                  RestartException;

public void ReActivate () throws SimulationException, RestartException;

public void Cancel () throws RestartException;

public void terminate ();

public synchronized boolean idle ();

public boolean passivated ();

public boolean terminated ();

public static SimulationProcess current () throws SimulationException;

public static double CurrentTime ();

public static void mainSuspend ();

public static void mainResume () throws SimulationException;

protected SimulationProcess ();

protected void set_evtime (double time) throws SimulationException;

protected void Hold (double t)throws SimulationException, RestartException;

protected void Passivate () throws RestartException;

};




The JavaSim Userâ€™s Manuals7.3 SimulationExceptionpackage arjuna.JavaSim.Simulation;

public class SimulationException extends Exception

{

public SimulationException ();

public SimulationException (String s);

};

7.4 RestartExceptionpackage arjuna.JavaSim.Simulation;

public class RestartException extends Exception

{

public RestartException ();

public RestartException (String s);

};

7.5 RandomStreampackage arjuna.JavaSim.Distributions;

public abstract class RandomStream

{

public abstract double getNumber () throws IOException,

ArithmeticException;

public final double Error ();

protected RandomStream ();

protected RandomStream (long MGSeed, long LCGSeed);

protected final double Uniform ();

};

7.6 UniformStreampackage arjuna.JavaSim.Distributions;

public class UniformStream extends RandomStream

{

public UniformStream (double lo, double hi);

public UniformStream (double lo, double hi, int StreamSelect);

public UniformStream (double lo, double hi, int StreamSelect,

                      long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};




The JavaSim Userâ€™s Manuals7.7 ExponentialStreampackage arjuna.JavaSim.Distributions;

public class ExponentialStream extends RandomStream

{

public ExponentialStream (double m);

public ExponentialStream (double m, int StreamSelect);

public ExponentialStream (double m, int StreamSelect,

  long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};

7.8 ErlangStreampackage arjuna.JavaSim.Distributions;

public class ErlangStream extends RandomStream

{

public ErlangStream (double mean, double sd);

public ErlangStream (double mean, double sd, int StreamSelect);

public ErlangStream (double mean, double sd, int StreamSelect,

           long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};

7.9 HyperExponentialStreampackage arjuna.JavaSim.Distributions;

public class HyperExponentialStream extends RandomStream

{

public HyperExponentialStream (double mean, double sd);

public HyperExponentialStream (double mean, double sd, int StreamSelect);

public HyperExponentialStream (double mean, double sd, int StreamSelect,

       long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};

7.10 NormalStreampackage arjuna.JavaSim.Distributions;

public class NormalStream extends RandomStream

{

public NormalStream (double mean, double sd);

public NormalStream (double mean, double sd, int StreamSelect);

public NormalStream (double mean, double sd, int StreamSelect,

         long MGSeed, long LCGSeed);

public double getNumber () throws IOException, ArithmeticException;

};




The JavaSim Userâ€™s Manuals7.11 Drawpackage arjuna.JavaSim.Distributions;

public class Draw

{

public Draw (double p);

public Draw (double p, int StreamSelect);

public Draw (double p, int StreamSelect, long MGSeed, long LCGSeed);

public boolean getBoolean () throws IOException;

};

7.12 SimulationEntitypackage arjuna.JavaSim.Simulation;

public class SimulationEntity extends SimulationProcess

{

public void Interrupt (SimulationEntity toInterrupt, boolean immediate)

                                   throws SimulationException,

RestartException;

public final void trigger ();

public void terminate ();

protected SimulationEntity ();

protected void Wait (double waitTime) throws SimulationException,

                                    RestartException, InterruptedException;

protected void WaitFor (SimulationEntity controller, boolean reAct)

             throws SimulationException, RestartException,

InterruptedException;

protected void WaitFor (SimulationEntity controller)

        throws SimulationException, RestartException, InterruptedException;

protected void WaitForTrigger (TriggerQueue _queue)

        throws SimulationException, RestartException, InterruptedException;

protected void WaitForSemaphore (Semaphore _sem) throws RestartException;

};

7.13 TriggerQueuepackage arjuna.JavaSim.Simulation;

public class TriggerQueue

{

public TriggerQueue ();

public void finalize ();

public synchronized void triggerFirst (boolean setTrigger)

                                             throws NoSuchElementException;

public synchronized void triggerFirst () throws NoSuchElementException;

public synchronized void triggerAll () throws NoSuchElementException;

};




The JavaSim Userâ€™s Manuals7.14 Semaphorepackage arjuna.JavaSim.Simulation;

public class SemaphoreOutcome

{

    static final public int DONE = 0;

    static final public int NOTDONE = 1;

    static final public int WOULD_BLOCK = 2;

};

public class Semaphore

{

public Semaphore ();

public Semaphore (long number);

public synchronized long NumberWaiting ();

public synchronized int Get (SimulationEntity toWait)

                                                   throws RestartException;

public synchronized int TryGet (SimulationEntity toWait)

                                                   throws RestartException;

public synchronized int Release ();

};

7.15 Meanpackage arjuna.JavaSim.Statistics;

public class Mean

{

public Mean ();

public void setValue (double value) throws IllegalArgumentException;

public void reset ();

public int numberOfSamples ();

public double min ();

public double max ();

public double sum ();

public double mean ();

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

public void print ();

};




The JavaSim Userâ€™s Manuals7.16 Variancepackage arjuna.JavaSim.Statistics;

public class Variance extends Mean

{

public Variance ();

public void setValue (double value) throws IllegalArgumentException;

public void reset ();

public double variance ();

public double stdDev ();

public double confidence (double value);

public void print ();

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

};

7.17 TimeVariancepackage arjuna.JavaSim.Statistics;

public class TimeVariance extends Variance

{

public TimeVariance ();

public void reset ();

public void setValue (double value) throws IllegalArgumentException;

public double timeAverage ();

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

};




The JavaSim Userâ€™s Manuals7.18 PrecisionHistogrampackage arjuna.JavaSim.Statistics;

public class PrecisionHistogram extends Variance

{

public PrecisionHistogram ();

public void finalize ();

public void setValue (double value) throws IllegalArgumentException;

public void reset ();

public long numberOfBuckets ();

public double sizeByIndex (long index) throws StatisticsException,

                                              IllegalArgumentException;

public double sizeByName (double name) throws IllegalArgumentException;

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

public void print ();

};

7.19 Histogrampackage arjuna.JavaSim.Statistics;

public class Histogram extends PrecisionHistogram

{

public Histogram (long maxIndex, int mergeChoice);

public Histogram (long maxIndex);

public void setValue (double value) throws IllegalArgumentException;

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

public void print ();

};




The JavaSim Userâ€™s Manuals7.20 SimpleHistogrampackage arjuna.JavaSim.Statistics;

public class SimpleHistogram extends PrecisionHistogram

{

public SimpleHistogram (double min, double max, long nbuckets);

public SimpleHistogram (double min, double max, double w);

public void setValue (double value) throws IllegalArgumentException;

public void reset ();

public double sizeByName (double name) throws IllegalArgumentException;

public double Width ();

public void print ();

public boolean saveState (String fileName) throws IOException;

public boolean saveState (DataOutputStream oFile) throws IOException;

public boolean restoreState (String fileName) throws FileNotFoundException,

                                                     IOException;

public boolean restoreState (DataInputStream iFile) throws IOException;

};

7.21 Quantilepackage arjuna.JavaSim.Statistics;

public class Quantile extends PrecisionHistogram

{

public Quantile ();

public Quantile (double q) throws IllegalArgumentException;

public double getValue ();

public double range ();

public void print ();

};

7.22 StatisticsExceptionpackage arjuna.JavaSim.Statistics;

public class StatisticsException extends Exception

{

public StatisticsException ();

public StatisticsException (String s);

};




The JavaSim Userâ€™s Manuals8. References[1]G. M. Birtwistle, O-J. Dahl, B. Myhrhaug, K. Nygaard, â€œSimula Beginâ€, AcademicPress, 1973[2]O�J. Dahl, B. Myhrhaug, K. Nygaard, â€œSIMULA Common Base Languageâ€,Norwegian Computing Centre[3]Knuth Vol2, â€œSeminumerical Algorithmsâ€, Addison�Wesley, 1969, p. 117.[4]R. Sedgewick, â€œAlgorithmsâ€, Addison�Wesley, Reading MA, 1983, pp. 36�38.[5]D. L. McCue and M. C. Little, â€œComputing Replica Placement in DistributedSystemsâ€, Proceedings of the 2nd IEEE Workshop on the Management of ReplicatedData, November 1992, pp. 58�61.[6]I. Mitrani, â€œSimulation Techniques for Discrete Event Systemsâ€, CambridgeUniversity Press, Cambridge, 1982.[7]M. C. Little and D. L. McCue, â€œThe Replica Management System: a Scheme forFlexible and Dynamic Replicationâ€, Proceedings of the 2nd International Workshopon Configurable Distributed Systems, March 1994, pp. 46�57.[8]G. D. Parrington et al, â€œThe Design and Implementation of Arjunaâ€, BroadcastProject Technical Report, October 1994.




The JavaSim Userâ€™s Manuals9. IndexActivating a process................................12Contact person..........................................5Controlling a simulation.........................14example.............................................14Platform....................................................5Processes.................................................10class definition..................................11Re-activating a process...........................12Resetting a simulation.............................15Restarting a simulation...........................15Scheduler..................................................9class definition..................................10Simulation models....................................6continuous time..................................7continuous time-discrete event...........7discrete time........................................7Terminology.............................................6
