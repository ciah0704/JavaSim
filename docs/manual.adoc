= JavaSim Manual Version 2.0
:numbered:

JavaSim is an object-oriented, discrete event simulation toolkit for Java. It's a Java implementation of the original link:http://www.cs.newcastle.ac.uk/publications/articles/papers/200.pdf[C++SIM simulation toolkit], which was developed as a direct consequence of research conducted within the scope of the link:http://www.ncl.ac.uk/computing/research/publication/159390[Arjuna project from Newcastle University] in the 1980's. Therefore, it shares many of the same requirements:

* easy to learn and use: the interface to the simulation library should be easy to understand.
* correct abstraction: existing Java programmers should not find the simulation paradigm in conflict with the programming paradigm presented by Java. Simulation programmers used to other environments should find the transition to JavaSim straightforward.
* flexible and extensible: it should be relatively easy for anyone to add new functionality to the system, such as new distribution functions.
* efficiency: the system should be efficient and produce efficient simulation runs. Simulation packages which we have experience of tended to be extremely slow and consume large amounts of system resources.

These requirements were realised in the following design decisions:

- the discrete-event process based simulation facilities provided by SIMULA and its simulation classes and libraries have a considerable experience and user community which have found them to be successful for a wide variety of simulations. In later versions of the system additional simulation classes were added which provide extra functionality.

- inheritance was to be used throughout the design to even a greater extent than is already provided in SIMULA. This enables JavaSim to be more flexible and extensible, allowing new functionality to be added without affecting the overall system structure. For example, our I/O facilities, random number generators and probability distribution functions are entirely object-oriented, relying on inheritance to specialise their behaviour.

NOTE: It is not necessary for the reader to know anything about the SIMULA programming language or its simulation classes, but such knowledge would aid in the understanding of the concepts and classes presented within.

Currently JavaSim has been tested with JDK 1.7 and 1.8. In the past it has worked with all versions of Java starting with 1.0.2. However, we have not tested with older versions for a long time, so your mileage may vary. If you have any problems, questions, suggestions etc. then consider raising an issue on the link:https://github.com/nmcl/JavaSim/issues[github page] or even fork JavaSim and raise a pull request.

== Introduction

This manual is not intended as a tutorial on the concepts of simulation in general, but rather how to write simulations in the JavaSim system. However, in order to be able to do this certain key simulation concepts will be briefly described. The interested reader is referred to link:http://dl.acm.org/citation.cfm?id=539335 [this book] for detailed descriptions of these concepts and for further discussions on simulation modelling.

=== Simulation Models

To model a system is to replace it by something which is:

- simpler and/or easier to study. 

- equivalent to the original in all important respects. 

Therefore, before constructing the actual simulation, it is first necessary to abstract from the real system those components and their interactions that are considered important for the actual model. Building a simulation system model involves making certain simplifying assumptions to aid in the actual implementation and study of the simulation (without such simplifications the model would be as complex as the system it is meant to be simulating). However, the accuracy of the results obtained from the simulation depend upon how valid the initial assumptions are. For example, when considering the trajectory of a projectile through the atmosphere, the friction due to the air molecules is usually ignored. This assumption is valid only within certain boundaries: if the size of the projectile is on the same scale as the air molecules and its speed is sufficiently small then friction plays a significant role in its movement.

Thus, the first step towards building a simulation model of a system is to determine exactly what are the important features which are to be measured, and what characteristics of the system have an affect on them. Any boundary conditions for the simulation (e.g., size of projectile) should be considered at the same time in order to simplify this procedure. Building a final model can often take several phases, where results from the initial model are compared with those obtained from the real system to determine their accuracy. Any discrepancies are taken into account by possibly adding new components to the simulation until, within certain error boundaries, the simulation results match those from the real system.

=== Terminology

The system components chosen for the simulation are termed simulation entities. Associated with each _entity_ in the simulation are zero or more _attributes_ that describe the state of the entity and which may vary during the course of the simulation. The interaction of entities and the changes they cause in the system state are termed _events_.

The collection of these component attributes at any given time _t_ defines the system state at _t_. In general, the system state can take any of a variety of values, and a given simulation run results in one realisation of a set of these values (the _operation path_) over the _observation period_.

=== Categories of simulation models

There are three categories of simulation model, described by the way in which the system state changes as a function of time:

- _Continuous time_: is one whose state varies continuously with time; such systems are usually described by sets of differential equations. 

- _Discrete time_: the system is considered only at selected moments in time (the observation points). These moments are typically evenly spaced. Some economics models are examples of this, where economics data becomes available at fixed intervals. Changes in state are noticed only at observation points. By choosing a suitably small interval between observation points, a continuous time simulation can be approximated by a discrete time simulation. 

- _Continuous time-discrete event_: the time parameter is (conceptually) continuous and the observation period is a real interval, usually starting at zero for simplicity. The operation path is completely determined by the sequence of event times (which need not be evenly spaced and can be of arbitrary increments) and by the discrete changes in the system state which take place at these times (i.e., the interactions of the events). In between consecutive event times the system state may vary continuously. Although it is possible to model the passage of real time by suitable event timing, this is not necessary for a discrete event system: the simulation model can advance its own internal time directly from one discrete event to another, taking any appropriate action to advance the state accordingly. 

It is this latter category of simulation modelling that JavaSim supports. Examples of discrete-event simulations are most queuing problems: entities (e.g., customers in a bank) arrive according to a given distribution and change the system state instantaneously (e.g., the number of customers in the queue). The operation paths for this system are step functions: they jump up (or down) by one when a customer joins (or leaves) the queue.

=== Event scheduling

Given that a simulation consists of a series of interacting events (the operation path), a simulator can be defined as that program devoted to the generation of operation paths. The simulator allows the creation of events and controls their interactions according to a set of rules, using an internal “clock” to keep track of the passage of (simulation) time.

It maintains an _event list_, which indicates which events are to be scheduled for execution at specific simulation times. Events are executed according to their simulation times. There are two approaches to the way in which a simulator can schedule events to produce an operation path:

- _event-oriented_: there is a procedure associated with each type of event in the system: it performs the action required to handle that type of event and it is invoked every time such an event occurs. In an event-oriented approach, an operation path is obtained by taking a global view of everything that happens in the system; the manipulation of events is explicit. 

- _process-oriented_: an operation path is obtained by the interacting of a number of processes running in parallel. The management of events is implicit in the management of the processes. The simulation system provides primitives for placing processes at particular points on the event list, removing and re-scheduling them. 
The JavaSim User’s Manuals

The process-oriented approach best fits with the object-oriented paradigm which we want to present to the programmer of JavaSim. As in SIMULA, simulation processes then become active objects which interact with each other through message passing and the simulation primitives. Refinements of these objects can then be obtained by inheriting from them and redefining the appropriate methods.

== Basic simulation classes

This section describes the core elements of the JavaSim simulation system. It is not intended as a tutorial on Java, and basic knowledge of the language is assumed. Note, all of the classes described in this section can be found in the org.javasim package.

=== The simulation scheduler

The previous section described the event list and how simulation entities (processes) are executed according to their position on the event list (i.e., with increasing simulation time). In JavaSim, as in SIMULA, simulation processes are managed by a _scheduler_ and are placed on a _scheduler queue_ (the event list). Processes are executed in pseudo-parallel, i.e., only one process executes at any instance of real time, but many processes may execute concurrently at any instance of simulation time. The simulation clock is only advanced when all processes have been executed for the current instance of simulation time.

Inactive processes are placed on to the scheduler queue, and when the current active process yields control to the scheduler (either because it has finished or been placed back onto the scheduler queue), the scheduler removes the process at the head of the queue and re-activates it. (In SIMULA the currently active process is not removed from the head of the queue.) When the scheduler queue is empty, i.e., there are no further processes left to execute, the scheduler terminates the simulation.

FIGURE 1 GOES HERE!!

Figure 1: Scheduler-Process Interaction

As Figure 1 shows, the scheduler co-ordinates the entire simulation run, effectively monitoring the active and passive processes to enable it to determine when, and which, process to activate next. A simulation application cannot affect the scheduler directly, but can do so only indirectly through modifications of the scheduler queue.

NOTE: the scheduler queue can be structured in a variety of ways, including a linear list or a tree. The implementation of the queue can depend upon the type of simulation being conducted. For example, a simulation which involves many (concurrent) processes would suffer from using a linear ordered queue which would typically have insertion and removal routines with overheads proportional to the number of entries in the queue. However, a linear list may work best for a low number of simulation processes. JavaSim comes with a suite of scheduler queue implementations which can be chosen when the system is built.

==== Scheduler and Simulation classes

The simulation scheduler is an instance of the Scheduler class. It is the responsibility of the application programmer to ensure that only a single instance of this class is created.

NOTE: In recent versions of JavaSim the Simulation class has taken on some of the functionality previously incorporated within the Scheduler class.

----
public class Scheduler extends Thread
{
    public static double currentTime ();
}
----

The scheduler maintains the simulation clock, and the current value of this clock is obtained by invoking the CurrentTime() method.

----
public class Simulation
{
    public static synchronized void reset () throws SimulationException;
    
    public static synchronized boolean isReset ();
    
    public static synchronized void stop ();
    
    public static synchronized void start ();
}
----

To enable multiple simulation runs to occur within a single application, it is possible to reset it and the simulation clock by calling the reset() method of the Simulation class. This causes the simulation to remove all processes (simulation objects) currently registered on the scheduler queue and to invoke a class specific method on each of them which resets their states (detailed in the next section). Once this is finished the simulation is ready for an additional run. A suspended process is informed that it has been “reset” by having the method it called to originally suspend itself (i.e., place itself on the scheduler queue) raise the RestartSimulation exception, which the object should catch. It must then perform any work necessary to put itself back in a state ready for restarting the simulation, and should then suspend itself again before the simulation can be restarted (typically by calling cancel.)

A process can use isReset to determine whether or not the simulation has been reset. The start and stop operations allow the simulation to be halted or resumed respectively.

=== Simulation processes

As was described in the previous sections, JavaSim supports the process-oriented approach to simulation, where each simulation entity can be considered a separate process. Therefore in JavaSim the entities within a simulation are represented by _process objects_. These are Java objects which have an independent thread of control associated with them at creation time, allowing them to convey the notion of activity necessary for participating in the simulation.

In keeping with the object-oriented paradigm, and to make development of process objects simpler, classes inherit the process functionality from the appropriate base class (SimulationProcess). This class defines all of the necessary operations for the simulation system to control the simulation entities within it, and for them to interact with it and each other.

At any point in simulation time, a process can be in one (and only one) of the following states:

- _active_: the process has been removed from the head of the scheduler queue and its actions are being executed. 

- _suspended_: the process is on the scheduler queue, scheduled to become active at a specified simulation time. 

- _passive_: the process is not on the scheduler queue. Unless another process brings it back on to the queue it will not execute any further actions.

- _terminated_: the process is not on the scheduler queue and has no further actions to execute. Once a process has been terminated it cannot be made to execute further in the same simulation run. 

A process which is either active or suspended is said to be _scheduled_.

==== SimulationProcess class

The SimulationProcess class definition is shown below. Before considering how to build an example class derived from SimulationProcess we shall discuss the methods which it provides.

Because the constructors are protected, it is not possible to create an instance of the SimulationProcess class, i.e., classes must be derived from this. Processes are threaded objects, and typically each thread package schedules execution of threads according to a priority. By default, all processes in JavaSim are created with the same priority, but this can be altered by calling the setPriority method of java.lang.Thread.

NOTE: Thread priorities have no effect on a simulation run.

----
public class SimulationProcess extends Thread
{
    public final double time ();
    public synchronized SimulationProcess nextEv () throws SimulationException, NoSuchElementException;
    public final double evtime ();
    public void activateBefore (SimulationProcess p) throws SimulationException, RestartException;
    public void activateAfter (SimulationProcess p) throws SimulationException, RestartException;
    public void activateAt (double AtTime, boolean prior) throws SimulationException, RestartException;
    public void activateAt (double AtTime) throws SimulationException, RestartException;
    public void activateDelay (double Delay, boolean prior) throws SimulationException, RestartException;
    public void activate () throws SimulationException, RestartException;
    public void reactivateBefore (SimulationProcess p) throws SimulationException, RestartException;
    public void reactivateAfter (SimulationProcess p) throws SimulationException, RestartException;
    public void reactivateAt (double AtTime, boolean prior) throws SimulationException, RestartException;
    public void reactivateAt (double AtTime) throws SimulationException, RestartException;
    public void reactivateDelay (double Delay, boolean prior) throws SimulationException, RestartException;
    public void reactivateDelay (double Delay) throws SimulationException, RestartException;
    public void reactivate () throws SimulationException, RestartException;
    public void cancel () throws RestartException;
    public void terminate ();
    public synchronized boolean idle ();
    public boolean passivated ();
    public boolean terminated ();
    public static SimulationProcess current () throws SimulationException;
    public static double currentTime ();
    public static void mainSuspend ();
    public static void mainResume () throws SimulationException;
    
    protected void hold (double t) throws SimulationException, RestartException;
    protected void passivate () throws RestartException;
    protected void setEvtime (double time) throws SimulationException;
    protected void suspendProcess () throws RestartException;
    protected void resumeProcess ();
}
----

There are five ways to activate a currently passive process, which results in it being brought to the correct position in the scheduler queue corresponding to its associated simulation time. If this is the head of the queue then it will become the active process.

- activate(): this activates the process at the current simulation time. 

- activateBefore(SimulationProcess proc): this positions the process in the scheduler queue before proc, and gives it the same simulation time. If proc is not present then a SimulationException will be thrown. 

- activateAfter(SimulationProcess proc): this positions the process in the scheduler queue after proc, and gives it the same simulation time. If proc is not present then a SimulationException will be thrown. 

- activateAt(double AtTime, boolean prior): the process is inserted into the scheduler queue at the position corresponding to the simulation time specified by AtTime. The default for this time is the current simulation time. The prior parameter is used to determine whether this process should be inserted before or after any processes with the same simulation time which may already be present in the queue. The default is false. 

- activateDelay(double AtTime, boolean prior): the process is activated after a specified delay (AtTime). The process is inserted into the queue with the new simulation time, and the prior parameter is used to determine its ordering with respect to other processes in the queue with the same time. The default is false. 

There are correspondingly five reActivate methods, which work on either passive or scheduled processes. These will not be described in detail as they have similar signatures to their Activate counterparts and work in the same way.

- hold(double period) schedules the currently active process for re-activation after the simulated delay of period time. If this is invoked by the object (e.g., through a publicly available method) when it is not the current active process then it does nothing.

- evtime() returns the time at which the process is scheduled for activation.

- nextEv() returns a reference to the next process to be scheduled for execution. If the queue is empty then null is returned.

The static method current() returns a reference to the currently active process.

The current simulation time can be obtained by using either the currentTime() or time() methods. The former method is static and as such can be invoked without an instance of the SimulationProcess class.

cancel() removes the process from the scheduler queue or suspends it if it is the currently active process. In either case, the process is set to the passive state. passivate() functions similarly but only works on the currently active process, i.e., if it is invoked by the object (e.g., through a publicly available method) when it is not the current active process then it does nothing.

terminate() removes the process from the scheduler queue or it is suspended if it is currently active. The process is then set to the terminated state, and can take no further part in this simulation run.

idle() returns false if the process is either active or scheduled to become active. Otherwise true is returned.

passivated() and terminated() indicate whether the process is in the passive or terminated state, respectively.

Because SimulationProcess extends the java.lang.Thread class it is necessary for the simulation class to provide an implementation of the run method which will do the actual work for the process. If this method ever returns then the thread is destroyed. However, in order for JavaSim to detect the termination of the thread, the terminate() method _must_ be used instead.

===== Example

To illustrate how a simulation process could be implemented from the Process class we shall consider the example of a queue of customers arriving at a bank. For this example, this involves three classes:

- Customer: instances of this class represent the customers in the queue. 

- Queue: the instance of this class (queue) is the queue into which customers are places. 

- Arrivals: this is the process which creates new customers for insertion in queue. 

The implementations of the Customer and Queue classes are not important to this example. The implementation of the Arrivals class could be:

----
class Arrivals extends SimulationProcess
{
    public void run ()
    {
        for  (;;)
        {
            Customer c = new Customer();
            
            queue.insert(c);
            hold(20.0);
        }
    }
}
----
